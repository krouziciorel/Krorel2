
1. Dvě postavy začínající v jediné místnosti - vyřešeno

Bystou Losici a koně se světlou hřívou jsem definoval jako postavy:

bystraLosice : Person 'indiánka' 'indiánka' *3
    @mistnostPredTipimDivkyPripravujiciSeNaTanec

kunSeSvetlouHrivou : OutOfReach, UntakeableActor 'kůň' 'kůň' *1
    @mistnostPredTipimDivkyPripravujiciSeNaTanec

Pokud dojdu do místnosti, vidím úsměvnou hlášku:

Kůň a indiánku stoj{íš poser}.


Proto jsem zatím koně definoval jako objekt třídy Immovable.




- problém jsem vyřešil tak, že jsem každé postavě přidělil  specialDesc = "Losice stojí před týpím. "
- koně tedy znovu definuji jako UntakeableActor, zatím bez OutofReach


2. Pokud např. legíny nechci dovolit hráči na sebe, je nutno využít metodu dobjFor(Wear), žádná xxxmessage nepomůže.



----------------------------------------------------------------------------------------------------------------------



3. Lze nějak simulovat změnu dne a noci? V manuálech ani na internetu jsem nic nenašel. Udělám tedy pro
každou místnost denní i noční verzi, noc se spustí např. po zahájení taneční slavnosti.



----------------------------------------------------------------------------------------------------------------------



4. Nefunguje příkaz "jdi do týpí", ale funguje např. "jdi dovnitř"
- zde je třeba využít Enterable, musel bych však nejspíš mít vše např. v souboru předTypimLovce podobně jako v Heidi
- mohu ale napsat do tipů ve hře, že tuto funkci zatím nepoužívat a zeptám se na fóru

Krásné ránko přeji,

hlásím, že vývoj jde podle plánu, nejvíce času zaberou detaily typu přesného popisu všeho možného, správné mluvnické
rody a košaté rozhovory. Zatím jsem si poradil se všemi potížemi ohledně postav, práce s oděvy i kontejnery, opravdu
mi velmi pomáhá, když se umím podívat do knihovny funkcí a metod, kterou jsem si upravil pro Zeal. Dnes jsem dokonce
zjistil, že nejsem zdaleka sám, kdo vyvíjí hru z indiánského prostředí, hra This land is my land vypadá moc pěkně, sice
si jí na svém železe opravdu nepustím, ale i ta videa stojí za to.

Zeptal bych se na jednu drobnost, kterou sice umím vyřešit, ale rád bych věděl, zda je možné elegantní řešení vzhledem
ke struktuře mých zdrojáků. Jedná se o využití třídy Enterable, pokud chci např. jít do týpí, mohu zadat "dovnitř" nebo
"jdi dovnitř", ale po zadání "jdi to týpí" dostanu odpověď "To není něco, do čeho bys mohl vstoupit". Situaci chápu,
ostatně popisuješ jí ve svém návodu a také v Getting Started in TADS3 je na straně 56 přesně vysvětleno, co a proč dělat 
plus v Library a souboru travel.t je krásně vidět provázanost jednotlivých tříd.
V příloze zasílám minimální zdrojáky pro postavu a dvě místnosti, je možné při této struktuře docílit funkčnosti příkazu
"jdi to týpí"? Pokud to nebude možné, nezbývá mi vše předělat tak jak popisuje manuál a je vyřešeno např. u chaty v Heidi.

Plus bych měl ještě něco z druhého soudku, TADS stále prozkoumávám a z Frobtads 1.2.3 jsem již před časem přešel na verzi 
1.2.4. Vše je OK, jen pokud se pokouším zkompilovat Základnu, dostávám následující chybové hlášení:

symbol_export itemTablet.t -> obj/itemTablet.t3s
Neoprávněný přístup do paměti (SIGSEGV) (core dumped [obraz paměti uložen])

Program v Cčku bych např. projel pomocí GDB a Valgrindu, zde v TADSu debugger nemám. Mohu poprosit o simulaci, docela by
mě zajímalo, kde může být problém, protože se s ním při své budoucí tvorbě mohu setkat taky.

Jdu makat dále, tvorba mě čím dál více baví a to parádní způsob pro další vývoj.

---

Citace: Kroužící orel  15. Leden 2020 - 10:33

    Je možné při této struktuře docílit funkčnosti příkazu "jdi to týpí"? Pokud to nebude možné, nezbývá mi vše předělat tak jak popisuje manuál a je vyřešeno např. u chaty v Heidi.


Myslíš bez použití EntryPortalu? No zkusil jsem níže uvedené a zdálo se mi, že to funguje bez problému, tedy že jsem enterable přesměroval na cílovou lokaci, takže se zdá, že není potřeba směrovat na místní objekt představující dveře, který směruje na protilehlou lokaci, ale jde směrovat rovnou na cíl.

Kód: [Vybrat]

+ typiBystrehoRysa : Enterable, CustomImmovable -> mistnostTypiBystrehoRysa 'týpí' 'týpí' *4


----------------------------------------------------------------------------------------------------------------------

5. Orlí jámy - problémy s dobjforLieOn

Na hře stále pracuji, mám hotovo cca 70 procent, takže jsem byl s rychlejším dokončením přeci jen přílišný optimista.
Je ale jasné, že se někde seknu, zatím jsem na většinu programátorských nástrah přišel. Už několik dní se ale pachtím s 
akcí dobjFor(LieOn) a jak vidno, potřebuji si ujasnit věci, které se snažím aplikovat ne tak jak autoři při tvorbě jazyka předpokládali. 
V příloze zasílám aktuální situaci s několika potřebnými místnostmi.

Ve hře se nachází orlí jámy určené na lov těchto dravců, potřebuji, aby hra reagovala na příkaz "lehni si do jámy" s tím,
že pokud má hráč nůž a návnadu, akce se provede a po zpracování opeřence získám nové předměty.


Pokud nemám v ruce žádný předmět, vše je OK a vyskočí hláška, kterou potřebuji:


>lehni si do jámy
Orla musím nejen na něco chytit, ale také mít šikovný předmět na zpracování masa a peří, nic nesmí zůstat nevyužito.


Pro úspěšný lov potřebuji mít v ruce nůž a návnadu. I přes můj kód však stačí mít jen jediný předmět, např. nůž a ještě
se text opakuje, místo aby hra zobrazila blok uvedený v else. Předměty typu PresentLater se v pořádku objeví:


>inv
Neseš nůž a na sobě máš bederní roušku, opasek, orlí medicínu a mokasíny.

>lehni si do jámy
Takže Ty se opravdu nebojíš lovu orlů...

>lehni si do jámy
Takže Ty se opravdu nebojíš lovu orlů...

>roz
Jihozápadní hranice prérie (ležíš na jámách)
Na jámách je orlí maso, orlí perutě, orlí pera a orlí letky.



Nejde mi jen o vyřešení problému, ale pochopení toho, co dělám špatně, přeci jen z Pecinovského Javy využívám IDE typu BlueJ, kde krásně graficky vidím provázanost tříd, objektů a volaných metod, zde mi není jasné následující:

V referenční knihovně si vyhledám Akce a rozkliknu LieOnAction, pokud dobře chápu, zjišťuji, že se jedná o třídu dědící od tříd TAction a Action a také od BasicProd a Resolver (které jsou však označeny jako objekty, i když po rozkliknutí jako třídy, zde se asi bude jednat o ten minimální rozdíl mezi třídou a objektem, který uvádíš ve svém manuálu). V sumáři vlastností a metod třídy LieOnAction vidím několik akcí xxx dobj xxx (snad se vyjadřuji přesně), nikoliv však akci s názvem dobjFor(LieOn), kterou potřebuji použít. Dobrá, vyhledám si všechny metody s názvem dobjFor(LieOn) (zde netuším, zda mohu akci typu dobj nebo iobj chápat jako metodu?) a vidím:
 
dobjFor(LieOn) - method of ComplexContainer in extras.t[207]
dobjFor(LieOn) - method of Thing in thing.t[10072]
dobjFor(LieOn) - method of Room in travel.t[4617]
dobjFor(LieOn) - method of NestedRoomFloor in travel.t[5161]
dobjFor(LieOn) - method of Floor in travel.t[5336]
dobjFor(LieOn) - method of BasicChair in travel.t[6440]
dobjFor(LieOn) - method of NominalPlatform in travel.t[6730]

Zde mě zaráží, že jsem nedohledal žádné propojení s třídou LieOnAction, tady něco chápu špatně. Potřebuji pracovat s věcmi v inventáři, takže se juknu blíže na aplikaci této metody ve spojení s třídou Thing a dostávám předpis:

    dobjFor(LieOn)
    {
        preCond = [touchObj]
        verify() { illogical(&cannotLieOnMsg); }
    }

Já se však ve svém kódu snažím využít nikoliv preCond a verify (mohu je chápat jako atributy metody?), ale verify, check a action společně s podmínkou začínající příkazem if a končící else, nakonec se snažím umožnit hráči nejen si s potřebnými předměty lehnout do jámy, ale také při položení obou věcí dosáhnout téhož pomocí dobjFor(PutIn) asDobjFor(LieOn). 

Pokud dobře chápu, potřebuji rozšířit funkcionalitu metody dobjFor(LieOn) tak, abych mohl využít atributů verify, check a action. Je nepříjemné, že můj zápis hra nebere jako chybu (syntaktická to pro kompilátor není, sémantická však ano, pokud dobře rozumím, i tak je chování zvláštní, neměl by TADS při překladu zařvat, že se snažím volat neexistující atributy?).

Něco mi holt uniká, nechápu zatím propojení mezi třídou LieOnAction a metodou dobjFor(LieOn), tuším, že zde takové propojení bude např. přes třídu Thing a její metody.

Tohle ale pro další tvorbu musím pochopit, jinak na netriviálních akcích ztroskotám. Je mi jasné, že jsem se u Exoteru ptal na každou prkotinu, protože bez chápání výše uvedeného jsem se dál prostě nemohl dostat a jen zkoušel, zda nějaký zápis projde či nikoliv (a podobně jako zde se mi to např. s hořící pochodní podařilo, hru kompilátor přeložil, ale chovala se jinak, než jsem zamýšlel).


Moc se omlouvám za sakra dlouhou zprávu, snažil jsem se vyjádřit co nejpodrobněji. Mohu poprosit o objasnění - nejde jen o vyřešení problému, ale hlavně o postup a vysvětlení, co dělám špatně? Je mi jasné, že až mi tyto věci docvaknou, bude už šumák, jaký jazyk pro tvorbu použiji (samozřejmě budu-li se pohybovat v rámci OOP, pokud se nemýlím), protože stále více vidím, že princip programování je u všech těchto jazyků podobný. Pecinovského "Architektura nejdříve" a využití návrhových vzorů a UML bude parádní pro vymýšlení jak mám funkcionalitu programu navrhnout, šikovná metodika, např. programování řízené testy a právě pochopení propojení třída - objekt - metody mi umožní program konkrétně zapsat. Tak vývojařinu v současné době chápu, pokud se mýlím, nevadí, člověk se stále učí.

Zatím se loučí

Orel

----------------------------------------------------------------------------------------------------------------------

















Poznámky pro pozdější vývoj -
Luk - budu asi definovat jako Container pro šípy
